function n(n,r,t){if(!Array.isArray(n)&&null==n)throw null!=t?t:new Error(`Invalid Index: ${r}`);if(!Array.isArray(n))return n;if(r<0&&n.length+r>=0){return n[n.length+r]}if(n.length<=r)throw null!=t?t:new Error(`Invalid Index: ${r}/ ${n.length}`);const e=n[r];if(null==e)throw null!=t?t:new Error(`Invalid Index: ${r}/ ${n.length}`);return e}function r(n,r){if(!Array.isArray(n)&&null==n)return;if(!Array.isArray(n))return n;if(r<0&&n.length+r>=0){return n[n.length+r]}if(n.length<=r)return;const t=n[r];return null!=t?t:void 0}function t(n,r){return Array.from({length:Math.ceil(n.length/r)},((t,e)=>n.slice(e*r,e*r+r)))}function e(n,r,t){const e=n.find(r);if(null==e)throw null!=t?t:new Error("findOrThrow got undefined result");return e}function u(n){if(Array.isArray(n)){const r=function(n){const[r]=n;return r}(n);if(null==r)throw new Error("invalid first index");return r}return n}function i(n,r){return Math.random()*(r-n)+n}function o(n,r){const t=Math.ceil(n),e=Math.floor(r);return Math.floor(Math.random()*(e-t))+n}function l(n){return!n}function f(n){return null==n||(!("number"!=typeof n||!Number.isNaN(n))||("string"==typeof n&&""===n||(!!("object"==typeof n&&Array.isArray(n)&&n.length<1)||"object"==typeof n&&!(n instanceof Date)&&Object.keys(n).length<1)))}function c(n){return null===n}function a(n){return void 0===n}function s(n){return a(n)||c(n)}function h(n,r){return n instanceof Error||null!=n&&"object"==typeof n&&"message"in n&&"stack"in n?n:null!=r?r:void 0}function y(n){return!n}function d(n){return!f(n)}function w(n){return!c(n)}function A(n){return!a(n)}function g(n){return A(n)&&w(n)}function v(n){return n}function m(n,r){return n.reduce(((n,t)=>({...n,[t[r]]:t})),{})}function E(n,r){return n.reduce(((n,t)=>({...n,[t[r]]:[...n[t[r]]??[],t]})),{})}function b(n){const r=n[n.length-1];if(null==r)throw new Error("invalid last index");return r}function p(n,r){if(null!=n)return n;throw r??new Error("invalid value")}function x(n){try{return null!=n&&("false"!==n&&("true"===n||!0===n))}catch{return!1}}function I(n,r){const t=null==r?0:1;return new Array(n).fill(0).map(((n,r)=>r+t))}function M(n){return Array.from(new Set(n))}async function j(n=1e3){return new Promise((r=>{setTimeout((()=>r(void 0)),n)}))}function $(n){return Array.isArray(n)?n:[n]}function k(n){return Object.keys(n)}export{n as atOrThrow,r as atOrUndefined,t as chunk,e as findOrThrow,u as first,i as getRandomRange,o as getRandomRangeInt,l as invert,f as isComplexEmpty,s as isEmpty,h as isError,y as isFalse,d as isNotComplexEmpty,g as isNotEmpty,w as isNotNull,A as isNotUndefined,c as isNull,v as isTrue,a as isUndefined,m as keyBy,E as keyBys,b as last,p as orThrow,x as parseBool,I as populate,M as settify,j as sleep,$ as toArray,k as typedkey};
